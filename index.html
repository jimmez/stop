<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>V40 Stopwatch â€“ YouTube Playlist Timer</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    html, body, #root { height: 100%; }
    body { font-family: Helvetica, Arial, sans-serif; }
  
    /* Subtle pulsing glow for 'Every 10s' mode */
    
    /* Subtle glowing ring around the stopwatch */
    
    /* Subtle glowing ring around the stopwatch with tunable flow */
    
    /* Smooth oval glow blob around the stopwatch (layered + brightness adjustable) */
    .pulse-ring {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: var(--blob-w, 60vw);
      height: var(--blob-h, 40vw); /* non-square => oval */
      border-radius: 9999px;       /* ellipse */
      background:
        radial-gradient(ellipse at 50% 50%,
          rgb(var(--pulse-rgb, 255 120 120) / 0.18) 0%,
          rgb(var(--pulse-rgb, 255 120 120) / 0.12) 45%,
          rgb(var(--pulse-rgb, 255 120 120) / 0.06) 65%,
          rgb(var(--pulse-rgb, 255 120 120) / 0.00) 80%);
      box-shadow:
        0 0 120px rgb(var(--pulse-rgb, 255 120 120) / 0.12),
        inset 0 0 220px rgb(var(--pulse-rgb, 255 160 160) / 0.10);
      animation: ringPulse var(--pulse-duration, 10s) ease-in-out infinite;
      filter: blur(10px) brightness(var(--boost, 1));
      pointer-events: none;
      z-index: 10;
    }
    .pulse-ring::before,
    .pulse-ring::after {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background:
        radial-gradient(ellipse at 50% 50%,
          rgb(var(--pulse-rgb, 255 120 120) / 0.12) 0%,
          rgb(var(--pulse-rgb, 255 120 120) / 0.08) 50%,
          rgb(var(--pulse-rgb, 255 120 120) / 0.00) 80%);
      filter: blur(18px);
      pointer-events: none;
    }
    .pulse-ring::before {
      transform: scale(1.35);
      opacity: 0.35;
    }
    .pulse-ring::after {
      transform: scale(1.8);
      opacity: 0.22;
    }
    @keyframes ringPulse {
      0%   { transform: translate(-50%, -50%) scale(0.96); opacity: var(--pulse-min, 0.22); }
      25%  { transform: translate(-50%, -50%) scale(1.02); opacity: calc((var(--pulse-min, 0.22) + var(--pulse-max, 0.50))*0.5); }
      50%  { transform: translate(-50%, -50%) scale(1.08); opacity: var(--pulse-max, 0.50); } /* outward end */
      75%  { transform: translate(-50%, -50%) scale(1.02); opacity: calc((var(--pulse-min, 0.22) + var(--pulse-max, 0.50))*0.5); }
      100% { transform: translate(-50%, -50%) scale(0.96); opacity: var(--pulse-min, 0.22); } /* inward end */
    }

      25%  { transform: translate(-50%, -50%) scale(1.02); opacity: calc((var(--pulse-min, 0.22) + var(--pulse-max, 0.50))*0.5); }
      50%  { transform: translate(-50%, -50%) scale(1.08); opacity: var(--pulse-max, 0.50); } /* outward end */
      75%  { transform: translate(-50%, -50%) scale(1.02); opacity: calc((var(--pulse-min, 0.22) + var(--pulse-max, 0.50))*0.5); }
      100% { transform: translate(-50%, -50%) scale(0.96); opacity: var(--pulse-min, 0.22); } /* inward end */
    }

      25%  { transform: translate(-50%, -50%) scale(1.02); opacity: 0.32; }
      50%  { transform: translate(-50%, -50%) scale(1.08); opacity: 0.50; }  /* end of outward pulse (5s) */
      75%  { transform: translate(-50%, -50%) scale(1.02); opacity: 0.32; }
      100% { transform: translate(-50%, -50%) scale(0.96); opacity: 0.22; }  /* completed inward pulse (another 5s) */
    }
    
      50%      { transform: translate(-50%, -50%) scale(1.03); opacity: 0.42; }
    }

      50%      { transform: scale(1.25); opacity: 0.36; }
    }

  
    /* Startup signature graphic */
    .signature-wrap {
      position: fixed;
      left: 6%;
      top: 18%;
      z-index: 30;
      pointer-events: none;
      opacity: 0.95;
    }
    .signature-text {
      font-weight: 900;
      font-style: italic;
      letter-spacing: 0.06em;
      font-size: clamp(20px, 3.8vw, 46px);
      background: linear-gradient(90deg, rgba(255,255,255,0.95), rgba(255,200,200,0.95), rgba(255,255,255,0.95));
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      text-shadow: 0 2px 18px rgba(255,120,120,0.25), 0 0 8px rgba(255,255,255,0.25);
      transform: rotate(-2deg);
      filter: drop-shadow(0 4px 24px rgba(255,120,120,0.15));
      white-space: nowrap;
    }
    .signature-swoosh {
      position: absolute;
      left: -2%;
      top: 60%;
      width: 115%;
      height: 22px;
      background: radial-gradient(ellipse at center, rgba(255,140,140,0.35) 0%, rgba(255,140,140,0.12) 60%, rgba(255,140,140,0) 75%);
      filter: blur(6px);
      transform: rotate(-3deg);
    }

  
    /* Plain startup signature (Times font), fades in/out within 5s */
    .signature-plain {
      position: fixed;
      left: 16px;
      top: 76px; /* just below header area */
      font-family: "Times New Roman", Times, serif;
      font-size: 0.875rem; /* similar to button text size */
      color: rgba(255,255,255,0.85);
      opacity: 0;
      animation: sigFade 5s ease-in-out forwards;
      pointer-events: none;
      z-index: 25;
      text-shadow: 0 1px 2px rgba(0,0,0,0.25);
    }
    @keyframes sigFade {
      0% { opacity: 0; }
      15% { opacity: 1; }
      85% { opacity: 1; }
      100% { opacity: 0; }
    }

      @keyframes pingFast { 0% { opacity: 0.0; } 10% { opacity: 0.9; } 100% { opacity: 0.0; } }
    .animate-ping-fast { animation: pingFast 500ms ease-out 1; }
  </style>
</head>
<body class="text-blue-200">
  <div id="root" class="h-full"></div>
  <div id="yt-player" style="position:absolute;left:-9999px;width:1px;height:1px;opacity:0;"></div>

  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://www.youtube.com/iframe_api"></script>

  <script type="text/babel">
    const { useState, useEffect, useMemo, useRef, useCallback } = React;

    const BG_CYCLE = ['#2a0c0c','#2a1608','#0c2a16','#0b1933','#17123e','#2a0c3b'];

    const MUSIC_PRESETS_ALL = [
      { label: '1s', ms: 1000 }, { label: '2s', ms: 2000 }, { label: '3s', ms: 3000 },
      { label: '5s', ms: 5000 }, { label: '10s', ms: 10000 }, { label: '15s', ms: 15000 },
      { label: '20s', ms: 20000 }, { label: '30s', ms: 30000 }, { label: '1 min', ms: 60000 },
      { label: '1:30', ms: 90000 }, { label: '2:00', ms: 120000 }, { label: 'Full song', ms: null },
    ];
    const QUICK_MS = [5000, 10000, 15000];

    const MODES = ['Single', 'Next', 'Next+Shuffle'];
    // Injected defaults from JSON (first 3 slots prefilled)
    const DEFAULT_PLAYLIST_SLOTS = [
  'https://youtube.com/playlist?list=PLEXox2R2RxZKUmrWKNF61K-kZSov14Snr&si=tOROUpRMmngEZXVm',
  'https://youtube.com/playlist?list=PLyPTjSogIU3n_Zz734jvnAmeoQlaERcNK&si=bA2LgZZ3TedZqep1',
  'https://youtube.com/playlist?list=PLHg022HMFzFB7nKvmuvpyGTDPCV7-A8ux&si=-0LbKut547XzIRTI',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  ''
];
    const DEFAULT_PLAYLIST_NAMES = Array.from({ length: 20 }, () => '');
    const LS_KEY = 'v21_stopwatch_settings'; // new key to keep embedded defaults

    const clamp = (n, min, max) => Math.max(min, Math.min(max, n));
    const pad2 = (n) => String(n).padStart(2, '0');
    const clockHHMM = () => { const d = new Date(); return pad2(d.getHours()) + ':' + pad2(d.getMinutes()); };
    const extractPlaylistId = (input) => { if (!input) return ''; const s = input.trim(); if (/^[A-Za-z0-9_-]{10,}$/.test(s)) return s; try { const url = new URL(s); const list = url.searchParams.get('list'); if (list) return list; } catch (_) {} return s; };

    const SEC_MODES = { ON: 'on', OFF: 'off', FIRST_MIN: 'first_min', EVERY_10S: 'every_10s' };
    function formatDisplay(ms, mode) {
      const totalSec = Math.floor(Math.max(0, ms)/1000);
      const mm = Math.floor(totalSec/60);
      let ss = totalSec % 60;
      if (mode === SEC_MODES.OFF) return pad2(mm);
      if (mode === SEC_MODES.FIRST_MIN) return ms < 60000 ? (pad2(mm)+':'+pad2(ss)) : pad2(mm);
      if (mode === SEC_MODES.EVERY_10S) { if (ms < 120000) return pad2(mm)+':'+pad2(ss); ss = Math.floor(ss/10)*10; return pad2(mm)+':'+pad2(ss); }
      return pad2(mm)+':'+pad2(ss);
    }

    function App() {
      const [elapsed, setElapsed] = useState(0);
      const [running, setRunning] = useState(false);
      const [paused, setPaused] = useState(false);

      const [controlsVisible, setControlsVisible] = useState(true);
      // Extra stopwatch visibility: 'hidden' | 'loop3s' | 'always'
      const [extraSwVis, setExtraSwVis] = useState('loop3s');

      const [pinned, setPinned] = useState(false);
      const controlsTimerRef = useRef(null);

      // Defaults from JSON: Single, seconds first_min, length 30s, activeIndex 2
      const [secondsMode, setSecondsMode] = useState(SEC_MODES.FIRST_MIN);
      const [musicLenMs, setMusicLenMs] = useState(30000);
      const [mode, setMode] = useState(MODES[0]); // 'Single'
      const [playlistSlots, setPlaylistSlots] = useState(DEFAULT_PLAYLIST_SLOTS);
      const [playlistNames, setPlaylistNames] = useState(DEFAULT_PLAYLIST_NAMES);
      const [activeIndex, setActiveIndex] = useState(2);
      const [nowPlaying, setNowPlaying] = useState('');

      const [settingsOpen, setSettingsOpen] = useState(false);
      const [lengthsOpen, setLengthsOpen] = useState(false);

      const playerRef = useRef(null);
      const playerReadyRef = useRef(false);
      const playlistLoadedRef = useRef(false);
      const musicStopTimeoutRef = useRef(null);

      const rafRef = useRef(null);
      const startTimeRef = useRef(null);

      const [clock, setClock] = useState(clockHHMM());
      useEffect(() => { const id = setInterval(() => setClock(clockHHMM()), 1000); return () => clearInterval(id); }, []);

      const lastSAtRef = useRef(0);
      const fileInputRef = useRef(null);

      const [bgIndex, setBgIndex] = useState(0);

      const [slotBannerVisible, setSlotBannerVisible] = useState(false);
      const slotBannerTimerRef = useRef(null);
      const [jimmyVisible, setJimmyVisible] = useState(false);
      const [flashOnReset, setFlashOnReset] = useState(false);
      const [flashStrong, setFlashStrong] = useState(false);
      const [torchOnReset, setTorchOnReset] = useState(false);
      const [flashActive, setFlashActive] = useState(false);
      const triggerFlash = useCallback(() => { setFlashStrong(!isMobile); setFlashActive(true); setTimeout(() => { setFlashActive(false); setFlashStrong(false); }, 500); }, [isMobile]);
      const streamRef = useRef(null);
      const triggerTorchFlash = async () => {
        try {
          if (!navigator.mediaDevices?.getUserMedia) return;
          if (!streamRef.current) {
            streamRef.current = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
          }
          const track = streamRef.current.getVideoTracks()[0];
          const caps = track.getCapabilities?.() || {};
          if (!('torch' in caps)) return;
          await track.applyConstraints({ advanced: [{ torch: true }] });
          setTimeout(async () => { try { await track.applyConstraints({ advanced: [{ torch: false }] }); } catch(_) {} }, 300);
        } catch(_) {}
      };

      // Loop mode
      const [loopOn, setLoopOn] = useState(false);
      const enableLoop = useCallback(() => { setLoopOn(true); loopStartRef.current = performance.now(); }, []);
      const disableLoop = useCallback(() => { setLoopOn(false); setLoopTotalMs(0); loopStartRef.current = null; }, []);
      const [loopSecs, setLoopSecs] = useState(20);
      const [maxLoops, setMaxLoops] = useState(100);
      const [loopCount, setLoopCount] = useState(0);
      const nextLoopAtRef = useRef(null);
      const initLoopThresholds = useCallback((startMs=0) => {
        if (!loopOn) { nextLoopAtRef.current = null; return; }
        const interval = Math.max(1, loopSecs) * 1000;
        nextLoopAtRef.current = startMs + interval;
      }, [loopOn, loopSecs]);
      useEffect(() => { if (!running) return; initLoopThresholds(0); }, [loopOn, loopSecs]);

      // Beep sound (Web Audio)
      const [beepOn, setBeepOn] = useState(true);
      const [beepVol, setBeepVol] = useState(0.5);
      const [beepPitch, setBeepPitch] = useState(880);
      const [beepType, setBeepType] = useState('short');
      const [beepVolOpen, setBeepVolOpen] = useState(false);
      const beepVolTimerRef = useRef(null);
      const audioCtxRef = useRef(null);
      const ensureAudio = () => { if (!audioCtxRef.current) audioCtxRef.current = new (window.AudioContext || window.webkitAudioContext)(); return audioCtxRef.current; };
      const playBeep = useCallback((type='short') => {
        if (!beepOn) return;
        try {
          const ctx = ensureAudio();
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.type = 'sine';
          osc.frequency.value = beepPitch;
          gain.gain.value = 0.0001;
          osc.connect(gain).connect(ctx.destination);
          const now = ctx.currentTime;
          const dur = type === 'long' ? 0.35 : 0.12;
          gain.gain.setValueAtTime(0.0001, now);
          gain.gain.linearRampToValueAtTime(beepVol, now + 0.02);
          gain.gain.exponentialRampToValueAtTime(0.0001, now + dur);
          osc.start(now);
          osc.stop(now + dur + 0.02);
        } catch(_) {}
      }, [beepOn, beepVol, beepPitch]);
      const toggleBeep = useCallback((e) => { e?.stopPropagation?.(); setBeepOn(v=>!v); }, []);
      const onBeepPress = useCallback((e) => { e?.stopPropagation?.(); beepVolTimerRef.current = setTimeout(() => setBeepVolOpen(true), 450); }, []);
      const onBeepRelease = useCallback((e) => { e?.stopPropagation?.(); if (beepVolTimerRef.current) { clearTimeout(beepVolTimerRef.current); beepVolTimerRef.current = null; } setTimeout(() => setBeepVolOpen(false), 1200); }, []);

      // YouTube sound controls
      const [ytMuted, setYtMuted] = useState(false);
      const [ytVol, setYtVol] = useState(100);
      const [ytVolOpen, setYtVolOpen] = useState(false);
      const ytVolTimerRef = useRef(null);
      const toggleYtMute = useCallback((e) => {
        e?.stopPropagation?.();
        setYtMuted(v => {
          const nv = !v;
          try { if (nv) playerRef.current?.mute?.(); else { playerRef.current?.unMute?.(); playerRef.current?.setVolume?.(ytVol); } } catch(_) {}
          return nv;
        });
      }, [ytVol]);
      const onYtPress = useCallback((e) => { e?.stopPropagation?.(); ytVolTimerRef.current = setTimeout(() => setYtVolOpen(true), 450); }, []);
      const onYtRelease = useCallback((e) => { e?.stopPropagation?.(); if (ytVolTimerRef.current) { clearTimeout(ytVolTimerRef.current); ytVolTimerRef.current = null; } setTimeout(() => setYtVolOpen(false), 1200); }, []);
      useEffect(() => { try { playerRef.current?.setVolume?.(ytVol); } catch(_) {} }, [ytVol]);

      const jimmyTimerRef = useRef(null);

      // Reference to the stopwatch digits for sizing
      const digitsRef = useRef(null);

      const [locked, setLocked] = useState(false); // lock mode (from v20)
      // Auto-fullscreen on Android only
      useEffect(() => {
        const ua = (navigator.userAgent || '').toLowerCase();
        if (ua.includes('android')) {
          const de = document.documentElement;
          const req = de.requestFullscreen || de.webkitRequestFullscreen || de.mozRequestFullScreen || de.msRequestFullscreen;
          if (req) { try { req.call(de, { navigationUI: 'hide' }); } catch(_) { try { req.call(de); } catch(_) {} } }
        }
      }, []);


      // Pulse indicator only in 'Every 10s' mode while running
      const showPulse = running && !paused && secondsMode === SEC_MODES.EVERY_10S;

      // Flow Settings state (color/brightness/rate/size + panel)
      const [flowOpen, setFlowOpen] = useState(false);
      const [flowColor, setFlowColor] = useState('#ff7878');   // hex color
      const [flowMin, setFlowMin] = useState(0.22);            // 0..1
      const [flowMax, setFlowMax] = useState(0.50);            // 0..1
      const [flowDuration, setFlowDuration] = useState(20);    // seconds for full out+in cycle (default)
      const [flowSizeVW, setFlowSizeVW] = useState(70);        // ring size in vw

      // Helpers to convert hex to "r g b" for CSS vars
      const hexToRGB = useCallback((hex) => {
        try {
          const s = hex.replace('#','');
          const v = s.length===3 ? s.split('').map(c=>c+c).join('') : s;
          const r = parseInt(v.slice(0,2),16), g = parseInt(v.slice(2,4),16), b = parseInt(v.slice(4,6),16);
          return `${r} ${g} ${b}`;
        } catch { return '255 120 120'; }
      }, []);
      const flowRGB = useMemo(() => hexToRGB(flowColor), [flowColor, hexToRGB]);
      // Loop Settings page + platform detection + loop total
      const [loopOpen, setLoopOpen] = useState(false);
      const uaStr = (navigator.userAgent || '').toLowerCase();
      const isMobile = uaStr.includes('android') || uaStr.includes('iphone') || uaStr.includes('ipad');
      const loopStartRef = useRef(null);
      const [loopTotalMs, setLoopTotalMs] = useState(0);
      // --- Loop Time Wheel (Android-style 4 wheels) ---
      const [wheelOpen, setWheelOpen] = useState(false);
      const [wheelVals, setWheelVals] = useState({ tmin: 0, min: 0, tsec: 2, sec: 0 }); // default 20s
      const wheelIdleRef = useRef(null);
      const resetWheelIdle = useCallback(() => {
        if (wheelIdleRef.current) clearTimeout(wheelIdleRef.current);
        wheelIdleRef.current = setTimeout(() => setWheelOpen(false), 2000);
      }, []);
      const openWheel = useCallback(() => {
        // seed from current loopSecs
        const s = Math.max(0, Math.floor(loopSecs));
        const mm = Math.floor(s / 60);
        const ss = s % 60;
        setWheelVals({ tmin: Math.floor(mm/10), min: mm % 10, tsec: Math.floor(ss/10), sec: ss % 10 });
        setWheelOpen(true);
        resetWheelIdle();
      }, [loopSecs, resetWheelIdle]);
      const closeWheel = useCallback(() => { setWheelOpen(false); }, []);
      const setFromWheel = useCallback(() => {
        const total = (wheelVals.tmin*10 + wheelVals.min) * 60 + (wheelVals.tsec*10 + wheelVals.sec);
        setLoopSecs(clamp(total, 0, 5999)); // 99m 59s max
        setWheelOpen(false);
      }, [wheelVals]);
      const onWheelChange = useCallback((key, val) => {
        setWheelVals(v => ({ ...v, [key]: val }));
        resetWheelIdle();
      }, [resetWheelIdle]);

      // Long-press handling on Loop button to open wheel
      const longPressRef = useRef(null);
      const onLoopPressStart = useCallback((e) => {
        e?.stopPropagation?.();
        if (locked) return;
        if (longPressRef.current) clearTimeout(longPressRef.current);
        longPressRef.current = setTimeout(openWheel, 450);
      }, [openWheel, locked]);
      const onLoopPressEnd = useCallback((e) => {
        e?.stopPropagation?.();
        if (longPressRef.current) { clearTimeout(longPressRef.current); longPressRef.current = null; }
      }, []);


      // Compute an oval size that hugs the stopwatch digits (in vw units)
      const fitToDigits = useCallback(() => {
        try {
          const el = digitsRef.current;
          if (!el) return;
          const rect = el.getBoundingClientRect();
          const vw = (val) => (val / window.innerWidth) * 100;
          const vh = (val) => (val / window.innerHeight) * 100; // not used, but here if needed
          // Add some breathing room around the digits
          const targetW = Math.max(5, Math.min(90, vw(rect.width) * 1.08));
          const targetH = Math.max(5, Math.min(70, (rect.height / window.innerWidth) * 100 * 1.28));
          setFlowWidthVW(parseFloat(targetW.toFixed(1)));
          setFlowHeightVW(parseFloat(targetH.toFixed(1)));
        } catch(_) {}
      }, []);

      const [flowWidthVW, setFlowWidthVW] = useState(60);   // blob width (vw)
      const [flowHeightVW, setFlowHeightVW] = useState(40); // blob height (vw)
      const [flowBoost, setFlowBoost] = useState(1.0);      // 0.5 .. 3.0 brightness boost



      // Startup signature visible for first 5 seconds
      const [signatureVisible, setSignatureVisible] = useState(true);
      useEffect(() => {
        const t = setTimeout(() => setSignatureVisible(false), 5000);
        return () => clearTimeout(t);
      }, []);
      // Fullscreen support (Android + Chrome on PC)
      const [isFs, setIsFs] = useState(false);
      const enterFullscreen = useCallback(() => {
        const de = document.documentElement;
        const req = de.requestFullscreen || de.webkitRequestFullscreen || de.mozRequestFullScreen || de.msRequestFullscreen;
        if (req) { try { req.call(de, { navigationUI: 'hide' }); } catch(_) { try { req.call(de); } catch(_) {} } }
      }, []);
      const exitFullscreen = useCallback(() => {
        const ex = document.exitFullscreen || document.webkitExitFullscreen || document.mozCancelFullScreen || document.msExitFullscreen;
        if (ex) { try { ex.call(document); } catch(_) {} }
      }, []);
      const toggleFullscreen = useCallback((e) => {
        e?.stopPropagation?.();
        const fsEl = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
        if (!fsEl) enterFullscreen(); else exitFullscreen();
      }, [enterFullscreen, exitFullscreen]);
      useEffect(() => {
        const onFsChange = () => setIsFs(!!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement));
        document.addEventListener('fullscreenchange', onFsChange);
        document.addEventListener('webkitfullscreenchange', onFsChange);
        document.addEventListener('mozfullscreenchange', onFsChange);
        document.addEventListener('MSFullscreenChange', onFsChange);
        return () => {
          document.removeEventListener('fullscreenchange', onFsChange);
          document.removeEventListener('webkitfullscreenchange', onFsChange);
          document.removeEventListener('mozfullscreenchange', onFsChange);
          document.removeEventListener('MSFullscreenChange', onFsChange);
        };
      }, []);


      // Load from localStorage if present (no legacy migration to keep embedded defaults)
      useEffect(() => {
        try {
          let raw = localStorage.getItem(LS_KEY);
          if (raw) {
            const p = JSON.parse(raw);
            if (Array.isArray(p.playlistSlots)) setPlaylistSlots([...DEFAULT_PLAYLIST_SLOTS].map((_, i) => p.playlistSlots[i] || ''));
            if (Array.isArray(p.playlistNames)) setPlaylistNames([...DEFAULT_PLAYLIST_NAMES].map((_, i) => p.playlistNames[i] || ''));
            if (typeof p.activeIndex === 'number') setActiveIndex(clamp(p.activeIndex, 0, 19));
            if (typeof p.musicLenMs === 'number' || p.musicLenMs === null) setMusicLenMs(p.musicLenMs);
            if (MODES.includes(p.mode)) setMode(p.mode);
            if (p.flowColor) setFlowColor(p.flowColor);
            if (typeof p.flowMin === 'number') setFlowMin(p.flowMin);
            if (typeof p.flowMax === 'number') setFlowMax(p.flowMax);
            if (typeof p.flowDuration === 'number') setFlowDuration(p.flowDuration);
            if (typeof p.flowSizeVW === 'number') setFlowSizeVW(p.flowSizeVW);
            if (Object.values(SEC_MODES).includes(p.secondsMode)) setSecondsMode(p.secondsMode);
            if (typeof p.bgIndex === 'number') setBgIndex(p.bgIndex % BG_CYCLE.length);
            if (typeof p.beepOn === 'boolean') setBeepOn(p.beepOn);
            if (typeof p.beepVol === 'number') setBeepVol(p.beepVol);
            if (typeof p.beepPitch === 'number') setBeepPitch(p.beepPitch);
            if (typeof p.loopSecs === 'number') setLoopSecs(p.loopSecs);
            if (typeof p.maxLoops === 'number') setMaxLoops(p.maxLoops);
            if (typeof p.loopOn === 'boolean') setLoopOn(p.loopOn);
            if (typeof p.flashOnReset === 'boolean') setFlashOnReset(p.flashOnReset);
            if (typeof p.torchOnReset === 'boolean') setTorchOnReset(p.torchOnReset);
            if (typeof p.ytMuted === 'boolean') setYtMuted(p.ytMuted);
            if (typeof p.ytVol === 'number') setYtVol(p.ytVol);
            if (typeof p.flowWidthVW === 'number') setFlowWidthVW(p.flowWidthVW);
            if (typeof p.flowHeightVW === 'number') setFlowHeightVW(p.flowHeightVW);
            if (typeof p.flowBoost === 'number') setFlowBoost(p.flowBoost);
            if (typeof p.flowSizeVW === 'number' && (p.flowWidthVW == null)) setFlowWidthVW(p.flowSizeVW);

          }
        } catch(_) {}
      }, []);

      useEffect(() => { localStorage.setItem(LS_KEY, JSON.stringify({ playlistSlots, playlistNames, activeIndex, musicLenMs, mode, secondsMode, bgIndex, flowColor, flowMin, flowMax, flowDuration, flowWidthVW, flowHeightVW, flowBoost, beepOn, beepVol, beepPitch, loopSecs, maxLoops, loopOn, flashOnReset, torchOnReset, ytMuted, ytVol })); }, [playlistSlots, playlistNames, activeIndex, musicLenMs, mode, secondsMode, bgIndex, flowColor, flowMin, flowMax, flowDuration, flowWidthVW, flowHeightVW, flowBoost, beepOn, beepVol, beepPitch, loopSecs, maxLoops, loopOn, flashOnReset, torchOnReset, ytMuted, ytVol]);

      const activePlaylistId = useMemo(() => extractPlaylistId(playlistSlots[activeIndex] || ''), [playlistSlots, activeIndex]);
      const activePlaylistName = useMemo(() => (playlistNames[activeIndex] || ''), [playlistNames, activeIndex]);

      useEffect(() => {
        function onReady() { playerReadyRef.current = true; playlistLoadedRef.current = false; }
        function onStateChange(evt) {
          if (evt?.data === 1) {
            try { const data = playerRef.current?.getVideoData?.() || {}; if (data?.title) setNowPlaying(data.title); } catch (_) {}
          }
          if (evt?.data === 0 && musicLenMs === null) {
            if (mode === 'Next+Shuffle') { try { playerRef.current.setShuffle(true); playerRef.current.nextVideo(); playerRef.current.playVideo(); } catch(_) {} }
            else if (mode === 'Next') { try { playerRef.current.setShuffle(false); playerRef.current.nextVideo(); playerRef.current.playVideo(); } catch(_) {} }
          }
        }
        function initPlayer() {
          if (playerRef.current || !window.YT?.Player) return;
          playerRef.current = new window.YT.Player('yt-player', {
            height: '1', width: '1',
            playerVars: { autoplay: 0, controls: 0, modestbranding: 1, rel: 0, playsinline: 1, enablejsapi: 1 },
            events: { onReady, onStateChange },
          });
        }
        if (window.YT?.Player) initPlayer(); else { window.onYouTubeIframeAPIReady = initPlayer; }
      }, [musicLenMs, mode]);

      useEffect(() => { playlistLoadedRef.current = false; }, [activePlaylistId]);

      const clearMusicTimer = useCallback(() => { if (musicStopTimeoutRef.current) { clearTimeout(musicStopTimeoutRef.current); musicStopTimeoutRef.current = null; } }, []);
      const stopMusicOnly = useCallback((e) => { e?.stopPropagation?.(); clearMusicTimer(); try { playerRef.current?.stopVideo(); } catch(_) {} }, [clearMusicTimer]);
      const rescheduleMusicStop = useCallback(() => {
        clearMusicTimer();
        if (typeof musicLenMs === 'number' && musicLenMs > 0) {
          musicStopTimeoutRef.current = setTimeout(() => { try { playerRef.current?.pauseVideo(); } catch(_) {} musicStopTimeoutRef.current = null; }, musicLenMs);
        }
      }, [musicLenMs, clearMusicTimer]);
      const tryPlayWithUnmute = useCallback(() => {
        const p = playerRef.current; if (!p) return;
        try {
          p.unMute?.(); p.setVolume?.(100); p.playVideo?.();
          setTimeout(() => { try { const st = p.getPlayerState?.(); if (st !== 1) { p.mute?.(); p.playVideo?.(); setTimeout(() => { try { p.unMute?.(); } catch(_) {} }, 350); } } catch(_) {} }, 250);
        } catch(_) {}
      }, []);
      const ensureLoadedAndPlay = useCallback(() => {
        if (!playerReadyRef.current || !playerRef.current || !activePlaylistId) return;
        const p = playerRef.current;
        try {
          if (!playlistLoadedRef.current) { p.loadPlaylist({ listType: 'playlist', list: activePlaylistId, index: 0 }); playlistLoadedRef.current = true; }
          if (mode === 'Single') { tryPlayWithUnmute(); }
          else if (mode === 'Next+Shuffle') { p.setShuffle?.(true); p.nextVideo?.(); tryPlayWithUnmute(); }
          else { p.setShuffle?.(false); p.nextVideo?.(); tryPlayWithUnmute(); }
          setTimeout(() => { try { const data = p.getVideoData?.(); if (data?.title) setNowPlaying(data.title); } catch(_) {} }, 400);
          rescheduleMusicStop();
        } catch (e) { console.warn('YT play error:', e); }
      }, [activePlaylistId, mode, tryPlayWithUnmute, rescheduleMusicStop]);

      const playPrev = useCallback((e) => { e?.stopPropagation?.(); if (!playerReadyRef.current || !playerRef.current || !activePlaylistId) return;
        const p = playerRef.current; try { if (!playlistLoadedRef.current) { p.loadPlaylist({ listType: 'playlist', list: activePlaylistId, index: 0 }); playlistLoadedRef.current = true; } p.previousVideo?.(); tryPlayWithUnmute(); rescheduleMusicStop(); } catch(_) {} }, [activePlaylistId, tryPlayWithUnmute, rescheduleMusicStop]);
      const playNext = useCallback((e) => { e?.stopPropagation?.(); if (!playerReadyRef.current || !playerRef.current || !activePlaylistId) return;
        const p = playerRef.current; try { if (!playlistLoadedRef.current) { p.loadPlaylist({ listType: 'playlist', list: activePlaylistId, index: 0 }); playlistLoadedRef.current = true; } p.nextVideo?.(); tryPlayWithUnmute(); rescheduleMusicStop(); } catch(_) {} }, [activePlaylistId, tryPlayWithUnmute, rescheduleMusicStop]);

      const tick = useCallback((now) => {
        if (!running || paused) return;
        if (startTimeRef.current == null) startTimeRef.current = now - elapsed;
        const newElapsed = now - startTimeRef.current;
        setElapsed(newElapsed);
        if (loopOn && loopStartRef.current != null) { setLoopTotalMs(performance.now() - loopStartRef.current); }
        // Loop handling
        if (loopOn && nextLoopAtRef.current != null && newElapsed >= nextLoopAtRef.current) {
          setLoopCount(c => {
            const nc = c + 1;
            // At limit, stop
            if (nc >= maxLoops) {
              setRunning(false); setPaused(true); setControlsVisible(true);
              return nc;
            } else {
              startTimeRef.current = performance.now(); setElapsed(0);
              ensureLoadedAndPlay();
              nextLoopAtRef.current = 1000 * Math.max(1, loopSecs);
              return nc;
            }
          });
          return;
        }
        rafRef.current = requestAnimationFrame(tick);
      }, [elapsed, running, paused]);
      useEffect(() => { if (running && !paused) { rafRef.current = requestAnimationFrame(tick); return () => cancelAnimationFrame(rafRef.current); } return () => {}; }, [running, paused, tick]);

      const showControls = useCallback((ms=13000) => {
        setControlsVisible(true);
        if (controlsTimerRef.current) { clearTimeout(controlsTimerRef.current); controlsTimerRef.current = null; }
        if (!pinned) controlsTimerRef.current = setTimeout(() => setControlsVisible(false), ms);
      }, [pinned]);
      const showSlotBanner = useCallback((ms=10000) => {
        setSlotBannerVisible(true);
        if (slotBannerTimerRef.current) { clearTimeout(slotBannerTimerRef.current); slotBannerTimerRef.current = null; }
        slotBannerTimerRef.current = setTimeout(() => setSlotBannerVisible(false), ms);
      }, []);
      const hideControls = useCallback(() => {
        if (pinned) return; // keep visible while pinned
        if (controlsTimerRef.current) { clearTimeout(controlsTimerRef.current); controlsTimerRef.current = null; }
        setControlsVisible(false);
        showSlotBanner(10000);
      }, [showSlotBanner, pinned]);

      const showJimmy = useCallback(() => {
        setJimmyVisible(true);
        if (jimmyTimerRef.current) { clearTimeout(jimmyTimerRef.current); jimmyTimerRef.current = null; }
        jimmyTimerRef.current = setTimeout(() => setJimmyVisible(false), 3000);
      }, []);

      const startStopwatchAndMusic = useCallback(() => {
        setRunning(true); setPaused(false);
        playBeep('short');
        initLoopThresholds(0);
        setLoopCount(0);
        startTimeRef.current = performance.now(); setElapsed(0);
        playBeep('short');
        if (flashOnReset) triggerFlash();
        initLoopThresholds(0);
        ensureLoadedAndPlay();
        setBgIndex((i) => (i + 1) % BG_CYCLE.length);
        showSlotBanner(10000); showJimmy();
        if (!pinned) { setControlsVisible(true); if (controlsTimerRef.current) clearTimeout(controlsTimerRef.current); controlsTimerRef.current = setTimeout(() => setControlsVisible(false), 60000); }
      }, [ensureLoadedAndPlay, pinned, showSlotBanner, showJimmy]);
      const resetStopwatchAndMusic = useCallback(() => {
        if (!running) { startStopwatchAndMusic(); return; }
        startTimeRef.current = performance.now(); setElapsed(0);
        playBeep('short');
        if (flashOnReset) triggerFlash();
        initLoopThresholds(0);
        ensureLoadedAndPlay();
        setBgIndex((i) => (i + 1) % BG_CYCLE.length);
        showSlotBanner(10000); showJimmy();
        if (!pinned) { setControlsVisible(true); if (controlsTimerRef.current) clearTimeout(controlsTimerRef.current); controlsTimerRef.current = setTimeout(() => setControlsVisible(false), 60000); }
      }, [running, startStopwatchAndMusic, ensureLoadedAndPlay, showSlotBanner, showJimmy, pinned]);

      const handleGlobalTap = useCallback(() => { if (locked) return; resetStopwatchAndMusic(); }, [resetStopwatchAndMusic, locked]);
      const handlePauseToggle = useCallback((e) => {
        e?.stopPropagation?.();
        if (!running || locked) return;
        setPaused((p) => { const next = !p; if (!next) startTimeRef.current = performance.now() - elapsed; return next; });
      }, [running, elapsed, locked]);

      const setQuickLen = useCallback((ms, e) => { e?.stopPropagation?.(); if (locked) return; setMusicLenMs(ms); }, [locked]);

      useEffect(() => {
        const onKey = (e) => {
          if (locked) return;
          const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : '';
          if (tag === 'input' || tag === 'textarea' || e.isContentEditable) return;
          const key = (e.key || '').toLowerCase();
          if (key === ' ') { e.preventDefault(); resetStopwatchAndMusic(); }
          else if (key === 'p') { e.preventDefault(); handlePauseToggle(); }
          else if (key === 's') { e.preventDefault(); if (controlsVisible) { setPinned(false); hideControls(); } else { showControls(13000); } lastSAtRef.current = Date.now(); }
          else if (key === 'e') { if (Date.now() - lastSAtRef.current < 800) { e.preventDefault(); setSettingsOpen(true); showControls(13000); lastSAtRef.current = 0; } }
          else if (key === 'arrowright') { e.preventDefault(); playNext(); }
          else if (key === 'arrowleft') { e.preventDefault(); playPrev(); }
        };
        window.addEventListener('keydown', onKey);
        return () => window.removeEventListener('keydown', onKey);
      }, [resetStopwatchAndMusic, handlePauseToggle, showControls, hideControls, controlsVisible, playPrev, playNext, locked]);

      const exportSettings = useCallback((e) => {
        e?.stopPropagation?.();
        const data = { version: 'v21', playlistSlots, playlistNames, activeIndex, musicLenMs, mode, secondsMode, bgIndex };
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'stopwatch-settings.json'; a.click(); URL.revokeObjectURL(a.href);
      }, [playlistSlots, playlistNames, activeIndex, musicLenMs, mode, secondsMode, bgIndex]);
      const importSettingsFromFile = useCallback((e) => { e?.stopPropagation?.(); fileInputRef.current?.click(); }, []);
      const onImportFileChange = useCallback((e) => {
        const file = e.target.files && e.target.files[0]; if (!file) return;
        const reader = new FileReader();
        reader.onload = () => {
          try {
            const p = JSON.parse(reader.result);
            if (Array.isArray(p.playlistSlots)) setPlaylistSlots([...DEFAULT_PLAYLIST_SLOTS].map((_, i) => p.playlistSlots[i] || ''));
            if (Array.isArray(p.playlistNames)) setPlaylistNames([...DEFAULT_PLAYLIST_NAMES].map((_, i) => p.playlistNames[i] || ''));
            if (typeof p.activeIndex === 'number') setActiveIndex(clamp(p.activeIndex, 0, 19));
            if (typeof p.musicLenMs === 'number' || p.musicLenMs === null) setMusicLenMs(p.musicLenMs);
            if (Object.values(SEC_MODES).includes(p.secondsMode)) setSecondsMode(p.secondsMode);
            if (MODES.includes(p.mode)) setMode(p.mode);
            if (p.flowColor) setFlowColor(p.flowColor);
            if (typeof p.flowMin === 'number') setFlowMin(p.flowMin);
            if (typeof p.flowMax === 'number') setFlowMax(p.flowMax);
            if (typeof p.flowDuration === 'number') setFlowDuration(p.flowDuration);
            if (typeof p.flowSizeVW === 'number') setFlowSizeVW(p.flowSizeVW);
            if (typeof p.bgIndex === 'number') setBgIndex(p.bgIndex % BG_CYCLE.length);
            if (typeof p.beepOn === 'boolean') setBeepOn(p.beepOn);
            if (typeof p.beepVol === 'number') setBeepVol(p.beepVol);
            if (typeof p.beepPitch === 'number') setBeepPitch(p.beepPitch);
            if (typeof p.loopSecs === 'number') setLoopSecs(p.loopSecs);
            if (typeof p.maxLoops === 'number') setMaxLoops(p.maxLoops);
            if (typeof p.loopOn === 'boolean') setLoopOn(p.loopOn);
            if (typeof p.flashOnReset === 'boolean') setFlashOnReset(p.flashOnReset);
            if (typeof p.torchOnReset === 'boolean') setTorchOnReset(p.torchOnReset);
            if (typeof p.ytMuted === 'boolean') setYtMuted(p.ytMuted);
            if (typeof p.ytVol === 'number') setYtVol(p.ytVol);
            if (typeof p.flowWidthVW === 'number') setFlowWidthVW(p.flowWidthVW);
            if (typeof p.flowHeightVW === 'number') setFlowHeightVW(p.flowHeightVW);
            if (typeof p.flowBoost === 'number') setFlowBoost(p.flowBoost);
            if (typeof p.flowSizeVW === 'number' && (p.flowWidthVW == null)) setFlowWidthVW(p.flowSizeVW);

          } catch { alert('Invalid settings file.'); } finally { e.target.value = ''; }
        };
        reader.readAsText(file);
      }, []);

      return (
        <div className="min-h-screen w-full text-blue-200 flex flex-col relative" style={{ backgroundColor: BG_CYCLE[bgIndex] }} onClick={handleGlobalTap}>
          <input type="file" ref={fileInputRef} accept="application/json" className="hidden" onChange={onImportFileChange} />

          {/* LOCKED frame overlay */}
          {locked && <div className="fixed inset-0 border-4 border-dashed border-orange-400 z-40 pointer-events-none" />}

          {/* TOUCH BLOCKER overlay when locked */}
          {locked && <div className="fixed inset-0 z-40" />}
          {flashActive && <div className={ "fixed inset-0 z-40 animate-ping-fast pointer-events-none " + (flashStrong ? "bg-white" : "bg-white/70") } />}

          {/* Subtle pulse indicator when in Every 10s mode and running */}
          {showPulse && (
            <div
              className="pulse-ring"
              style={{
                '--pulse-rgb': flowRGB,
                '--pulse-min': flowMin,
                '--pulse-max': flowMax,
                '--pulse-duration': `${flowDuration}s`,
                '--pulse-size': `${flowSizeVW}vw`,
                animationDelay: `-${(elapsed % (flowDuration*1000))}ms`
              }}
            />
          )}

          {/* Startup signature (first 5 seconds) */}
          {signatureVisible && (
            <div className="signature-plain">Jimmy James - 13.10.2025</div>
          )}


          <header className="sticky top-0 z-30 w-full bg-black/10 backdrop-blur border-b border-blue-900">
            {beepVolOpen && (
              <div className="absolute left-4 top-14 z-50 bg-black/70 border border-purple-900 rounded-xl px-3 py-2">
                <div className="text-xs mb-1">Beep volume: {Math.round(beepVol*100)}</div>
                <input type="range" min="0" max="1" step="0.01" value={beepVol} onChange={(e)=>setBeepVol(parseFloat(e.target.value))} className="w-52" />
              </div>
            )}

            {ytVolOpen && (
              <div className="absolute right-4 top-14 z-50 bg-black/70 border border-green-900 rounded-xl px-3 py-2">
                <div className="text-xs mb-1">YT volume: {ytVol}</div>
                <input type="range" min="0" max="100" value={ytVol} onChange={(e)=>setYtVol(parseInt(e.target.value,10))} className="w-52" />
              </div>
            )}

            <div className="px-4 py-2 flex flex-wrap items-center gap-2">
              <div className="mr-2 font-extrabold flex-shrink-0" style={{ color: '#93C5FD' }}>
                <span className="text-4xl md:text-6xl leading-none">{clock}</span>
              </div>
              <div className={(controlsVisible ? 'opacity-100' : 'opacity-0 pointer-events-none') + ' transition-opacity duration-200 flex flex-wrap items-center gap-2'} onClick={(e) => e.stopPropagation()}>
                <div className="flex items-center rounded-xl border border-blue-800 overflow-hidden">
                  {MODES.map((m, idx) => (
                    <button key={m} onClick={() => !locked && setMode(m)} className={"px-3 py-2 text-sm " + (idx>0 ? "border-l border-blue-800 " : "") + (m===mode ? "bg-blue-100 text-blue-900" : "bg-blue-900/60 hover:bg-blue-800/60")}>{m}</button>
                  ))}
                </div>
                <div className="flex items-center gap-2">
                  <button onClick={(e)=>!locked && playPrev(e)} className="px-3 py-2 rounded-xl bg-blue-900/70 hover:bg-blue-800">Prev</button>
                  <button onClick={(e)=>!locked && playNext(e)} className="px-3 py-2 rounded-xl bg-blue-900/70 hover:bg-blue-800">Next</button>
                </div>
                <div className="flex items-center gap-2">
                  {QUICK_MS.map(ms => (
                    <button key={ms} onClick={(e) => setQuickLen(ms, e)} className={"px-3 py-2 rounded-xl border " + (musicLenMs===ms ? "bg-blue-100 text-blue-900 border-blue-100" : "bg-blue-900/70 border-blue-800 hover:bg-blue-800")}>
                      {Math.round(ms/1000)}s
                    </button>
                  ))}
                  <button onClick={()=>!locked && setLengthsOpen(true)} className="px-3 py-2 rounded-xl bg-blue-900/70 hover:bg-blue-800">More</button>
                  <button onMouseDown={onBeepPress} onMouseUp={onBeepRelease} onTouchStart={onBeepPress} onTouchEnd={onBeepRelease} onClick={toggleBeep} className="px-3 py-2 rounded-xl bg-purple-700 hover:bg-purple-600">{beepOn ? "Beep On" : "Beep Off"}</button>
                </div>
                {nowPlaying && (
                  <div className="ml-2 text-xs md:text-sm text-blue-300 truncate max-w-[70vw]" title={nowPlaying}>
                    Now playing: <span className="text-blue-100">{nowPlaying}</span>
                  </div>
                )}
                <div className="flex-1" />
                <div className="flex items-center gap-2">
                  <button onClick={(e)=>{ if (locked) return; setSettingsOpen(true); showControls(13000); }} className="px-3 py-2 rounded-xl bg-orange-600 hover:bg-orange-500 text-white">Settings</button>
                  <button onClick={handlePauseToggle} className="px-3 py-2 rounded-xl bg-blue-900/70 hover:bg-blue-800">{paused ? "Resume" : "Pause"}</button>
                  <button onMouseDown={onYtPress} onMouseUp={onYtRelease} onTouchStart={onYtPress} onTouchEnd={onYtRelease} onClick={toggleYtMute} className="px-3 py-2 rounded-xl bg-green-700 hover:bg-green-600">{ytMuted ? "YT Off" : "YT On"}</button>
                  <button onClick={stopMusicOnly} className="px-2 py-2 text-sm rounded-xl bg-red-600 hover:bg-red-500">Stop</button>
                  
                </div>
              </div>
            </div>
          </header>

          <main className="flex-1 relative">

          {/* Loop info band under header */}
          {((extraSwVis==='always') || (extraSwVis==='loop3s' && ((loopOn && elapsed < 3000) || (!loopOn && running)))) && (
            <div className="px-4 pt-2">
              <div className="flex items-center justify-between">
                {/* Total time on left */}
                <div className="font-extrabold text-blue-200 drop-shadow" style={{ fontSize: '8vw' }}>
                  {formatDisplay(elapsed, secondsMode)}
                </div>
                {/* Reps on right */}
                <div className="font-extrabold text-blue-200 drop-shadow ml-auto text-right" style={{ fontSize: '8vw' }}>
                  {`Rep ${loopCount}`}
                </div>
                
                
                
              </div>
            </div>
          )}

            <div className="fixed bottom-0 left-0 w-full" style={{ height: '10vh' }} onClick={(e) => { e.stopPropagation(); if (locked) return; if (controlsVisible) { setPinned(false); hideControls(); } else { showControls(13000); } }} />
            <button onClick={(e) => { e.stopPropagation(); if (locked) return; if (controlsVisible) { setPinned(false); hideControls(); } else { showControls(13000); } }} className="fixed bottom-6 left-1/2 -translate-x-1/2 w-14 h-14 rounded-full bg-blue-600 hover:bg-blue-500 shadow-lg active:scale-95 transition" title="Show/Hide controls"></button>

            <div className="grid place-items-center" style={{ marginTop: '25vh' }} onClick={(e) => { e.stopPropagation(); if (locked) return; resetStopwatchAndMusic(); }}>
              <div ref={digitsRef} className="text-[20vw] md:text-[12rem] leading-none font-extrabold drop-shadow" style={{ color: '#93C5FD', textShadow: '0 0 12px rgba(147,197,253,0.15)' }} aria-live="polite">
                {formatDisplay(elapsed, secondsMode)}
              </div>
            </div>

            <div className={(controlsVisible ? 'opacity-100' : 'opacity-0 pointer-events-none') + ' transition-opacity duration-200'} onClick={(e) => e.stopPropagation()}>
              <div className="mt-4 flex flex-col items-center gap-3 px-4">
                <div className="flex flex-wrap items-center justify-center gap-2">
                  <button onClick={() => !locked && (setPinned(v => !v), !pinned && showControls(13000))} className={"px-3 py-2 rounded-xl border " + (pinned ? "bg-blue-100 text-blue-900 border-blue-100" : "bg-blue-900/70 border-blue-800 hover:bg-blue-800")}>
                    {pinned ? "Unpin controls" : "Pin controls"}
                  </button>
                  <button onClick={() => (loopOn ? disableLoop() : enableLoop())} className={"px-3 py-2 rounded-xl border " + (loopOn ? "bg-green-200 text-green-900 border-green-200" : "bg-blue-900/70 border-blue-800 hover:bg-blue-800")}>{loopOn ? "Loop: On" : "Loop: Off"}</button>
                </div>
                <div className="flex flex-wrap items-center justify-center gap-2">
                  <button onClick={() => !locked && setSecondsMode(SEC_MODES.ON)} className={"px-3 py-2 rounded-xl border " + (secondsMode===SEC_MODES.ON ? "bg-blue-100 text-blue-900 border-blue-100" : "bg-blue-900/70 border-blue-800 hover:bg-blue-800")}>Show seconds</button>
                  <button onClick={() => !locked && setSecondsMode(SEC_MODES.OFF)} className={"px-3 py-2 rounded-xl border " + (secondsMode===SEC_MODES.OFF ? "bg-blue-100 text-blue-900 border-blue-100" : "bg-blue-900/70 border-blue-800 hover:bg-blue-800")}>Hide seconds</button>
                  <button onClick={() => !locked && setSecondsMode(SEC_MODES.FIRST_MIN)} className={"px-3 py-2 rounded-xl border " + (secondsMode===SEC_MODES.FIRST_MIN ? "bg-blue-100 text-blue-900 border-blue-100" : "bg-blue-900/70 border-blue-800 hover:bg-blue-800")}>First minute</button>
                  <button onClick={() => !locked && setSecondsMode(SEC_MODES.EVERY_10S)} className={"px-3 py-2 rounded-xl border " + (secondsMode===SEC_MODES.EVERY_10S ? "bg-blue-100 text-blue-900 border-blue-100" : "bg-blue-900/70 border-blue-800 hover:bg-blue-800")}>Every 10s</button>
                  <div className="flex flex-col items-center"><FsButton isFs={isFs} onToggle={toggleFullscreen} /><div className="text-[10px] mt-1 text-blue-300">''</div></div>
                </div>
              </div>
            </div>

            <div className="pointer-events-none fixed left-0 right-0 top-16 flex flex-col items-center gap-2 z-20">
              <div className={(jimmyVisible ? 'opacity-100 translate-y-0' : 'opacity-0 -translate-y-1') + ' transition-all duration-500 bg-black/50 text-blue-100 px-4 py-2 rounded-xl shadow'}>
                Jimmy James - 12.10.2025
              </div>
              <div className={(slotBannerVisible ? 'opacity-100 translate-y-0' : 'opacity-0 -translate-y-1') + ' transition-all duration-500 bg-blue-900/70 text-blue-100 px-4 py-2 rounded-xl shadow'}>
                Active playlist slot: <span className="font-semibold">{activeIndex + 1}</span>
                {activePlaylistName ? <span> â€” {activePlaylistName}</span> : null}
              </div>
            </div>

            <div className="absolute bottom-3 right-4 text-xs font-semibold" style={{ color: '#60A5FA' }}>V40</div>
          </main>

          {settingsOpen && (
            <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/70 p-4" onClick={(e) => { e.stopPropagation(); setSettingsOpen(false); }}>
              <div className="w-full max-w-4xl rounded-2xl bg-black/30 border border-blue-900 backdrop-blur" onClick={(e) => e.stopPropagation()}>
                <div className="flex items-center justify-between px-5 py-4 border-b border-blue-900">
                  <h2 className="text-lg font-semibold">playlist / settings</h2>
                  <div className="flex gap-2"><button onClick={(e) => { e.stopPropagation(); setSettingsOpen(false); }} className="px-3 py-2 rounded-xl bg-blue-900/70 hover:bg-blue-800">Close</button></div>
                </div>
                <div className="max-h-[65vh] overflow-y-auto p-5 space-y-4">
              {/* Extra Stopwatch Visibility */}
              <div className="border border-blue-900 rounded-xl p-4 bg-blue-900/30">
                <div className="font-semibold mb-2">Extra Stopwatch</div>
                <div className="text-xs text-blue-200 mb-3">Controls when the small extra stopwatch band shows below the header.</div>
                <div className="flex flex-col gap-2">
                  <label className="inline-flex items-center gap-2">
                    <input type="radio" name="extrasw" checked={extraSwVis==='hidden'} onChange={()=>setExtraSwVis('hidden')} />
                    <span>Hide</span>
                  </label>
                  <label className="inline-flex items-center gap-2">
                    <input type="radio" name="extrasw" checked={extraSwVis==='loop3s'} onChange={()=>setExtraSwVis('loop3s')} />
                    <span>Show only first 3s of each loop</span>
                  </label>
                  <label className="inline-flex items-center gap-2">
                    <input type="radio" name="extrasw" checked={extraSwVis==='always'} onChange={()=>setExtraSwVis('always')} />
                    <span>Always show</span>
                  </label>
                </div>
              </div>
    <div className="flex flex-wrap gap-2 mb-4"><button onClick={(e) => { e.stopPropagation(); exportSettings(e); }} className="px-3 py-2 rounded-xl bg-blue-900/70 hover:bg-blue-800">Export JSON</button><button onClick={(e) => { e.stopPropagation(); importSettingsFromFile(e); }} className="px-3 py-2 rounded-xl bg-blue-900/70 hover:bg-blue-800">Import JSON</button><button onClick={(e) => { e.stopPropagation(); setFlowOpen(true); }} className="px-3 py-2 rounded-xl bg-pink-600 hover:bg-pink-500 text-white">Flow Settings</button><button onClick={(e) => { e.stopPropagation(); setLoopOpen(true); }} className="px-3 py-2 rounded-xl bg-green-700 hover:bg-green-600 text-white">Loop Settings</button></div>
                  <p className="text-sm text-blue-300">Add up to 20 YouTube playlists. Give each a name (optional), paste a Playlist URL or ID, and choose the active slot.</p>
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
                    {playlistSlots.map((val, i) => (
                      <div key={i} className="rounded-xl border border-blue-900 p-3 space-y-2">
                        <label className="text-xs text-blue-300">Slot {i + 1}</label>
                        <input type="text" placeholder="Name (optional)" value={playlistNames[i]} onChange={(e) => { const next = [...playlistNames]; next[i] = e.target.value; setPlaylistNames(next); }} className="w-full rounded-lg bg-blue-900/60 border border-blue-800 px-3 py-2 outline-none focus:border-blue-400" />
                        <input type="text" placeholder="Playlist URL or ID" value={val} onChange={(e) => { const next = [...playlistSlots]; next[i] = e.target.value; setPlaylistSlots(next); }} className="w-full rounded-lg bg-blue-900/60 border border-blue-800 px-3 py-2 outline-none focus:border-blue-400" />
                        <div className="flex items-center justify-between text-xs">
                          <div className="text-blue-400 truncate">ID: {extractPlaylistId(val) || 'â€”'}</div>
                          <button onClick={(e) => { e.stopPropagation(); setActiveIndex(i); }} className={'ml-2 px-2 py-1 rounded-lg border text-xs transition ' + (activeIndex === i ? 'bg-blue-100 text-blue-900 border-blue-100' : 'bg-blue-900/70 border-blue-800 hover:bg-blue-800')}>{activeIndex === i ? 'Active' : 'Make Active'}</button>
                        </div>
                      </div>
                    ))}
                  </div>
                                  <div className="mt-6 pt-4 border-t border-blue-900">
                    <h3 className="font-semibold mb-2">Beep Settings</h3>
                    <div className="grid grid-cols-1 sm:grid-cols-2 gap-3 items-center">
                      <label className="text-blue-200">Beep enabled</label>
                      <input type="checkbox" checked={beepOn} onChange={(e)=>setBeepOn(e.target.checked)} />
                      <label className="text-blue-200">Beep volume</label>
                      <input type="range" min="0" max="1" step="0.01" value={beepVol} onChange={(e)=>setBeepVol(parseFloat(e.target.value))} />
                      <label className="text-blue-200">Beep type</label>
                      <select value={beepType} onChange={(e)=>setBeepType(e.target.value)} className="bg-blue-900/60 border border-blue-800 rounded px-2 py-1">
                        <option value="short">Short</option>
                        <option value="long">Long</option>
                      </select>
                      <label className="text-blue-200">Beep pitch (Hz)</label>
                      <input type="number" min="220" max="2000" step="10" value={beepPitch} onChange={(e)=>setBeepPitch(parseInt(e.target.value,10)||880)} className="bg-blue-900/60 border border-blue-800 rounded px-2 py-1" />
                    </div>
                  </div>

                </div>
                <div className="px-5 py-4 border-t border-blue-900 flex justify-end"><button onClick={(e)=>{ e.stopPropagation(); setSettingsOpen(false); }} className="px-3 py-2 rounded-xl bg-blue-900/70 hover:bg-blue-800">Close</button></div>
              </div>
            </div>
          )}


          {flowOpen && (
            <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/70 p-4" onClick={() => setFlowOpen(false)}>
              <div className="w-full max-w-xl rounded-2xl bg-black/30 border border-pink-900 p-5 backdrop-blur" onClick={(e) => e.stopPropagation()}>
                <div className="flex items-center justify-between mb-4">
                  <h2 className="text-lg font-semibold">Flow Settings</h2>
                  <button onClick={() => setFlowOpen(false)} className="px-3 py-2 rounded-xl bg-blue-900/70 hover:bg-blue-800">Close</button>
                </div>
                <div className="space-y-4 text-sm">
                  <div className="flex items-center justify-between gap-4">
                    <label className="text-blue-200">Color</label>
                    <input type="color" value={flowColor} onChange={(e)=>setFlowColor(e.target.value)} className="w-10 h-10 rounded border border-blue-800 bg-blue-900/50" />
                  </div>
                  <div>
                    <label className="block mb-1 text-blue-200">Brightness (min / max)</label>
                    <div className="flex items-center gap-3">
                      <input type="range" min="0" max="1" step="0.01" value={flowMin} onChange={(e)=>setFlowMin(parseFloat(e.target.value))} className="w-full" />
                      <span className="w-12 text-right">{flowMin.toFixed(2)}</span>
                    </div>
                    <div className="flex items-center gap-3 mt-1">
                      <input type="range" min="0" max="1" step="0.01" value={flowMax} onChange={(e)=>setFlowMax(parseFloat(e.target.value))} className="w-full" />
                      <span className="w-12 text-right">{flowMax.toFixed(2)}</span>
                    </div>
                  </div>
                  <div className="flex items-center justify-between gap-4">
                    <label className="text-blue-200">Pulse cycle (seconds)</label>
                    <input type="number" min="4" max="60" step="1" value={flowDuration} onChange={(e)=>setFlowDuration(Math.max(4, Math.min(60, parseInt(e.target.value||'10',10))))} className="w-20 rounded bg-blue-900/60 border border-blue-800 px-2 py-1" />
                  </div>
                  <div className="flex items-center justify-between gap-4">
                    <label className="text-blue-200">Blob width (vw)</label>
                    <input type="range" min="5" max="90" step="1" value={flowWidthVW} onChange={(e)=>setFlowWidthVW(parseInt(e.target.value,10))} className="w-full" />
                  
                  <div className="flex items-center justify-between gap-4 mt-2">
                    <label className="text-blue-200">Blob height (vw)</label>
                    <input type="range" min="5" max="70" step="1" value={flowHeightVW} onChange={(e)=>setFlowHeightVW(parseInt(e.target.value,10))} className="w-full" />
                  </div>
                  <div className="flex items-center justify-between gap-4 mt-2">
                    <button onClick={fitToDigits} className="px-3 py-2 rounded-xl bg-blue-900/70 hover:bg-blue-800">Fit to stopwatch</button>
                  </div>
                  <div className="flex items-center justify-between gap-4 mt-2">
                    <label className="text-blue-200">Brightness boost</label>
                    <input type="range" min="0.5" max="3" step="0.05" value={flowBoost} onChange={(e)=>setFlowBoost(parseFloat(e.target.value))} className="w-full" />
                  </div>

                </div>
                  <p className="text-xs text-blue-400">Expansion starts at multiples of the selected cycle (e.g., :00, :20, :40...) and contraction at mid-cycles (e.g., :10, :30, :50...) based on the stopwatch time.</p>                  <div className="mt-6 pt-4 border-t border-blue-900">
                    <h3 className="font-semibold mb-2">Loop Settings</h3>
                    <div className="grid grid-cols-1 sm:grid-cols-2 gap-3 items-center">
                      <label className="text-blue-200">Enable loop mode</label>
                      <input type="checkbox" checked={loopOn} onChange={(e)=>setLoopOn(e.target.checked)} />
                      <label className="text-blue-200">Loop interval (seconds)</label>
                      <input type="number" min="1" max="600" step="1" value={loopSecs} onChange={(e)=>setLoopSecs(Math.max(1, parseInt(e.target.value||'20',10)))} className="bg-blue-900/60 border border-blue-800 rounded px-2 py-1" />
                      <label className="text-blue-200">Max loops per session</label>
                      <input type="number" min="1" max="10000" step="1" value={maxLoops} onChange={(e)=>setMaxLoops(Math.max(1, parseInt(e.target.value||'100',10)))} className="bg-blue-900/60 border border-blue-800 rounded px-2 py-1" />
                      <label className="text-blue-200">Flash screen at reset</label>
                      <input type="checkbox" checked={flashOnReset} onChange={(e)=>setFlashOnReset(e.target.checked)} />
                      <label className="text-blue-200">Use camera light (torch) if possible</label>
                      <input type="checkbox" checked={torchOnReset} onChange={(e)=>setTorchOnReset(e.target.checked)} />
                    </div>
                  </div>

                                  <div className="mt-6 pt-4 border-t border-blue-900">
                    <h3 className="font-semibold mb-2">Beep Settings</h3>
                    <div className="grid grid-cols-1 sm:grid-cols-2 gap-3 items-center">
                      <label className="text-blue-200">Beep enabled</label>
                      <input type="checkbox" checked={beepOn} onChange={(e)=>setBeepOn(e.target.checked)} />
                      <label className="text-blue-200">Beep volume</label>
                      <input type="range" min="0" max="1" step="0.01" value={beepVol} onChange={(e)=>setBeepVol(parseFloat(e.target.value))} />
                      <label className="text-blue-200">Beep type</label>
                      <select value={beepType} onChange={(e)=>setBeepType(e.target.value)} className="bg-blue-900/60 border border-blue-800 rounded px-2 py-1">
                        <option value="short">Short</option>
                        <option value="long">Long</option>
                      </select>
                      <label className="text-blue-200">Beep pitch (Hz)</label>
                      <input type="number" min="220" max="2000" step="10" value={beepPitch} onChange={(e)=>setBeepPitch(parseInt(e.target.value,10)||880)} className="bg-blue-900/60 border border-blue-800 rounded px-2 py-1" />
                    </div>
                  </div>

                </div>
                <div className="px-5 py-4 border-t border-blue-900 flex justify-end"><button onClick={(e)=>{ e.stopPropagation(); setSettingsOpen(false); }} className="px-3 py-2 rounded-xl bg-blue-900/70 hover:bg-blue-800">Close</button></div>
              </div>
            </div>
          )}



          {wheelOpen && (
            <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/70 p-4" onClick={() => setWheelOpen(false)}>
              <div className="w-full max-w-2xl rounded-2xl bg-black/30 border border-green-900 p-5 backdrop-blur" onClick={(e) => { e.stopPropagation(); resetWheelIdle(); }}>
                <div className="flex items-center justify-between mb-4">
                  <h2 className="text-lg font-semibold">Loop Time</h2>
                  
                </div>
                {/* Wheels: 10s of minutes, minutes, 10s of seconds, seconds */}
                <div className="grid grid-cols-4 gap-3 mb-4">
                  {['tmin','min','tsec','sec'].map((key, idx) => (
                    <div key={key} className="rounded-xl border border-blue-900 bg-blue-900/40 h-56 overflow-y-auto snap-y">
                      {Array.from({length: idx<2?10:(idx==2?6:10)}, (_,i)=>i).map(n => (
                        <div
                          key={n}
                          onClick={() => onWheelChange(key, n)}
                          className={"snap-center text-center py-3 text-3xl cursor-pointer " + (wheelVals[key]===n ? "bg-blue-100 text-blue-900 font-extrabold" : "hover:bg-blue-800/60")}
                        >
                          {n}
                        </div>
                      ))}
                    </div>
                  ))}
                </div>
                <div className="flex items-center justify-between mb-4">
                  <div className="text-2xl font-bold">
                    {(wheelVals.tmin*10+wheelVals.min).toString().padStart(2,'0')}:
                    {(wheelVals.tsec*10+wheelVals.sec).toString().padStart(2,'0')}
                  </div>
                  <div className="flex items-center gap-2">
                    <button onClick={() => { onWheelChange('sec', (wheelVals.sec+9)%10); resetWheelIdle(); }} className="px-3 py-2 rounded-xl bg-blue-900/70 hover:bg-blue-800">âˆ’1s</button>
                    <button onClick={() => { onWheelChange('sec', (wheelVals.sec+1)%10); resetWheelIdle(); }} className="px-3 py-2 rounded-xl bg-blue-900/70 hover:bg-blue-800">+1s</button>
                    <button onClick={setFromWheel} className="px-3 py-2 rounded-xl bg-green-700 hover:bg-green-600 text-white">Set</button>
                  </div>
                </div>
                <div className="text-xs text-blue-300">Auto-closes after 2s of inactivity.</div>
                <div className="mt-4 flex justify-end">
                  
                </div>
                <div className="px-5 py-4 border-t border-blue-900 flex justify-end"><button onClick={(e)=>{ e.stopPropagation(); setSettingsOpen(false); }} className="px-3 py-2 rounded-xl bg-blue-900/70 hover:bg-blue-800">Close</button></div>
              </div>
            </div>
          )}

          {loopOpen && (
            <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/70 p-4" onClick={() => setLoopOpen(false)}>
              <div className="w-full max-w-xl rounded-2xl bg-black/30 border border-green-900 p-5 backdrop-blur" onClick={(e) => e.stopPropagation()}>
                <div className="flex items-center justify-between mb-4">
                  <h2 className="text-lg font-semibold">Loop Settings</h2>
                  <button onClick={() => setLoopOpen(false)} className="px-3 py-2 rounded-xl bg-blue-900/70 hover:bg-blue-800">Close</button>
                </div>
                <div className="space-y-4 text-sm">
                  {/* 4-wheel selector inside Loop Settings */}
                  <div className="grid grid-cols-4 gap-3">
                    {['tmin','min','tsec','sec'].map((key, idx) => (
                      <div key={key} className="rounded-xl border border-blue-900 bg-blue-900/40 h-40 overflow-y-auto snap-y">
                        {Array.from({length: idx<2?10:(idx==2?6:10)}, (_,i)=>i).map(n => (
                          <div
                            key={n}
                            onClick={() => onWheelChange(key, n)}
                            className={"snap-center text-center py-2 text-2xl cursor-pointer " + (wheelVals[key]===n ? "bg-blue-100 text-blue-900 font-extrabold" : "hover:bg-blue-800/60")}
                          >
                            {n}
                          </div>
                        ))}
                      </div>
                    ))}
                  </div>
                  <div className="flex items-center justify-between gap-4">
                    <div className="text-xl font-bold">
                      {(wheelVals.tmin*10+wheelVals.min).toString().padStart(2,'0')}:
                      {(wheelVals.tsec*10+wheelVals.sec).toString().padStart(2,'0')}
                    </div>
                    <div className="flex items-center gap-2">
                      <button onClick={() => setLoopSecs(Math.max(0, loopSecs-1))} className="px-3 py-2 rounded-xl bg-blue-900/70 hover:bg-blue-800">âˆ’1s</button>
                      <button onClick={() => setLoopSecs(loopSecs+1)} className="px-3 py-2 rounded-xl bg-blue-900/70 hover:bg-blue-800">+1s</button>
                      <input type="number" min="0" max="5999" step="1" value={loopSecs} onChange={(e)=>setLoopSecs(Math.max(0, parseInt(e.target.value||'0',10)))} className="w-24 bg-blue-900/60 border border-blue-800 rounded px-2 py-1" />
                      <button onClick={setFromWheel} className="px-3 py-2 rounded-xl bg-green-700 hover:bg-green-600 text-white">Set from wheels</button>
                    </div>
                  </div>
    
                  <div className="flex items-center justify-between gap-4">
                    <label className="text-blue-200">Enable loop mode</label>
                    <input type="checkbox" checked={loopOn} onChange={(e)=> e.target.checked ? enableLoop() : disableLoop()} />
                  </div>
                  <div className="flex items-center justify-between gap-4">
                    <label className="text-blue-200">Loop interval (seconds)</label>
                    <input type="number" min="1" max="600" step="1" value={loopSecs} onChange={(e)=>setLoopSecs(Math.max(1, parseInt(e.target.value||'20',10)))} className="w-24 rounded bg-blue-900/60 border border-blue-800 px-2 py-1" />
                  </div>
                  <div className="flex items-center justify-between gap-4">
                    <label className="text-blue-200">Max loops per session</label>
                    <input type="number" min="1" max="10000" step="1" value={maxLoops} onChange={(e)=>setMaxLoops(Math.max(1, parseInt(e.target.value||'100',10)))} className="w-24 rounded bg-blue-900/60 border border-blue-800 px-2 py-1" />
                  </div>
                  <div className="flex items-center justify-between gap-4">
                    <label className="text-blue-200">Flash screen at reset</label>
                    <input type="checkbox" checked={flashOnReset} onChange={(e)=>setFlashOnReset(e.target.checked)} />
                  </div>
                  <div className="flex items-center justify-between gap-4">
                    <label className="text-blue-200">Use camera light (torch) if possible</label>
                    <input type="checkbox" checked={torchOnReset} onChange={(e)=>setTorchOnReset(e.target.checked)} />
                  </div>
                </div>
                <div className="px-5 py-4 border-t border-blue-900 flex justify-end"><button onClick={(e)=>{ e.stopPropagation(); setSettingsOpen(false); }} className="px-3 py-2 rounded-xl bg-blue-900/70 hover:bg-blue-800">Close</button></div>
              </div>
            </div>
          )}


          {lengthsOpen && (
            <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/70 p-4" onClick={() => setLengthsOpen(false)}>
              <div className="w-full max-w-xl rounded-2xl bg-black/30 border border-blue-900 p-5 backdrop-blur" onClick={(e) => e.stopPropagation()}>
                <div className="flex items-center justify-between mb-4">
                  <h2 className="text-lg font-semibold">More lengths</h2>
                  <button onClick={() => setLengthsOpen(false)} className="px-3 py-2 rounded-xl bg-blue-900/70 hover:bg-blue-800">Close</button>
                </div>
                <div className="grid grid-cols-3 sm:grid-cols-4 gap-2">
                  {MUSIC_PRESETS_ALL.filter(p => !QUICK_MS.includes(p.ms)).map((p) => (
                    <button key={p.label} onClick={() => { setMusicLenMs(p.ms); setLengthsOpen(false); }} className={"px-3 py-2 rounded-xl border " + (musicLenMs===p.ms ? "bg-blue-100 text-blue-900 border-blue-100" : "bg-blue-900/70 border-blue-800 hover:bg-blue-800")}>
                      {p.label}
                    </button>
                  ))}
                                  <div className="mt-6 pt-4 border-t border-blue-900">
                    <h3 className="font-semibold mb-2">Beep Settings</h3>
                    <div className="grid grid-cols-1 sm:grid-cols-2 gap-3 items-center">
                      <label className="text-blue-200">Beep enabled</label>
                      <input type="checkbox" checked={beepOn} onChange={(e)=>setBeepOn(e.target.checked)} />
                      <label className="text-blue-200">Beep volume</label>
                      <input type="range" min="0" max="1" step="0.01" value={beepVol} onChange={(e)=>setBeepVol(parseFloat(e.target.value))} />
                      <label className="text-blue-200">Beep type</label>
                      <select value={beepType} onChange={(e)=>setBeepType(e.target.value)} className="bg-blue-900/60 border border-blue-800 rounded px-2 py-1">
                        <option value="short">Short</option>
                        <option value="long">Long</option>
                      </select>
                      <label className="text-blue-200">Beep pitch (Hz)</label>
                      <input type="number" min="220" max="2000" step="10" value={beepPitch} onChange={(e)=>setBeepPitch(parseInt(e.target.value,10)||880)} className="bg-blue-900/60 border border-blue-800 rounded px-2 py-1" />
                    </div>
                  </div>

                </div>
                <div className="px-5 py-4 border-t border-blue-900 flex justify-end"><button onClick={(e)=>{ e.stopPropagation(); setSettingsOpen(false); }} className="px-3 py-2 rounded-xl bg-blue-900/70 hover:bg-blue-800">Close</button></div>
              </div>
            </div>
          )}

          {/* ORANGE LOCK/UNLOCK BUTTON */}
          <button
            className="fixed bottom-6 left-6 w-14 h-14 rounded-full bg-orange-500 hover:bg-orange-400 active:scale-95 shadow-lg z-50 transition"
            onClick={(e) => { e.stopPropagation(); setLocked(v => !v); }}
            aria-label="Lock/Unlock"
          ></button>
        </div>
      );
    }


    function FsButton({ isFs, onToggle }) {
      return <button onClick={onToggle} className="px-3 py-2 rounded-xl bg-green-600 hover:bg-green-500 text-white">{isFs ? 'Exit Fullscreen' : 'Fullscreen'}</button>;
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    
  </script>
</body>
</html>

  
